{{- if .Values.polarisInit.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-polaris-init
  labels:
    {{- include "floe-infrastructure.labels" . | nindent 4 }}
    app.kubernetes.io/component: polaris-init
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "5"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        {{- include "floe-infrastructure.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: polaris-init
    spec:
      restartPolicy: Never
      initContainers:
        # Wait for Polaris to be ready using Quarkus management health endpoint
        - name: wait-for-polaris
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              echo "Waiting for Polaris to be ready..."
              until wget -q --spider http://{{ .Release.Name }}-polaris:8182/q/health/ready; do
                echo "Polaris not ready, waiting..."
                sleep 5
              done
              echo "Polaris is ready!"
      containers:
        - name: polaris-init
          image: python:3.12-slim
          command:
            - python
            - -c
            - |
              import json
              import os
              import sys
              import urllib.request
              import urllib.error
              import urllib.parse

              POLARIS_URI = os.environ["POLARIS_URI"]
              CATALOG_NAME = os.environ["CATALOG_NAME"]
              LAYER_CONFIG = os.environ["LAYER_CONFIG"]  # Required - no fallback
              STORAGE_ENDPOINT = os.environ["STORAGE_ENDPOINT"]
              CLIENT_ID = os.environ["POLARIS_CLIENT_ID"]
              CLIENT_SECRET = os.environ["POLARIS_CLIENT_SECRET"]
              STORAGE_ROLE_ARN = os.environ.get("STORAGE_ROLE_ARN", "")

              def get_oauth_token():
                  """Get OAuth2 token from Polaris."""
                  url = f"{POLARIS_URI}/api/catalog/v1/oauth/tokens"
                  data = urllib.parse.urlencode({
                      "grant_type": "client_credentials",
                      "client_id": CLIENT_ID,
                      "client_secret": CLIENT_SECRET,
                      "scope": "PRINCIPAL_ROLE:ALL"
                  }).encode()
                  req = urllib.request.Request(url, data=data, method="POST")
                  req.add_header("Content-Type", "application/x-www-form-urlencoded")
                  try:
                      with urllib.request.urlopen(req, timeout=30) as resp:
                          result = json.loads(resp.read().decode())
                          return result.get("access_token")
                  except urllib.error.HTTPError as e:
                      print(f"Failed to get OAuth token: {e.code} - {e.reason}")
                      return None

              def api_request(method, path, data=None, token=None):
                  """Make API request to Polaris."""
                  url = f"{POLARIS_URI}{path}"
                  headers = {"Content-Type": "application/json"}
                  if token:
                      headers["Authorization"] = f"Bearer {token}"
                  body = json.dumps(data).encode() if data else None
                  req = urllib.request.Request(url, data=body, headers=headers, method=method)
                  try:
                      with urllib.request.urlopen(req, timeout=30) as resp:
                          content = resp.read().decode()
                          # Handle empty responses (204 No Content or empty body)
                          if not content or content.strip() == "":
                              return resp.status, {}
                          return resp.status, json.loads(content)
                  except urllib.error.HTTPError as e:
                      return e.code, {"error": e.reason}
                  except Exception as e:
                      return 500, {"error": str(e)}

              print(f"Initializing Polaris catalog: {CATALOG_NAME}")
              print(f"Using credentials: {CLIENT_ID}")

              # Get OAuth2 token
              print("Obtaining OAuth2 token...")
              token = get_oauth_token()
              if not token:
                  print("ERROR: Failed to obtain OAuth2 token")
                  sys.exit(1)
              print("  Token acquired successfully")

              # Check for stale catalog state (validates cleanup worked)
              print("Checking for stale catalog state...")
              status, resp = api_request("GET", f"/api/catalog/v1/{CATALOG_NAME}/namespaces", token=token)
              if resp and resp.get('namespaces'):
                  existing_ns = ['.'.join(ns) for ns in resp['namespaces']]
                  print(f"⚠️  WARNING: Found existing namespaces: {existing_ns}")
                  print(f"⚠️  This may indicate incomplete cleanup.")
                  print(f"⚠️  Run 'make demo-cleanup-full' first for a clean deployment.")
                  print(f"⚠️  Continuing anyway (will attempt to work with existing state)...")
              else:
                  print("  ✅ No stale catalog state detected")

              # 1. Parse layer config to build allowed locations
              # Each layer has its own bucket, all must be in allowedLocations
              layers = json.loads(LAYER_CONFIG)
              allowed_locations = []
              default_base_location = None

              for layer_name, layer_data in layers.items():
                  bucket = layer_data["storage"]["bucket"]
                  location = f"s3://{bucket}/"
                  allowed_locations.append(location)
                  # Use first layer (bronze) as default base location
                  if default_base_location is None:
                      default_base_location = location

              print(f"Configuring catalog: {CATALOG_NAME}")
              print(f"  Allowed locations: {allowed_locations}")
              print(f"  Default base location: {default_base_location}")

              # 2. Create or update catalog with proper credential vending config
              # For vended credentials to work, Polaris needs (per OpenAPI spec):
              # - roleArn: The IAM role to assume when vending credentials
              # - endpoint: S3-compatible endpoint for LocalStack/MinIO
              # - pathStyleAccess: Required for LocalStack/MinIO
              storage_config = {
                  "storageType": "S3",
                  "allowedLocations": allowed_locations,
                  # Polaris AwsStorageConfigInfo uses flat keys per OpenAPI spec
                  "endpoint": STORAGE_ENDPOINT,
                  "pathStyleAccess": True,
                  "region": "us-east-1"
              }
              # Add roleArn for credential vending (required for STS AssumeRole)
              if STORAGE_ROLE_ARN:
                  storage_config["roleArn"] = STORAGE_ROLE_ARN
                  print(f"  Using IAM role for credential vending: {STORAGE_ROLE_ARN}")

              # Check if catalog exists
              status, resp = api_request("GET", f"/api/management/v1/catalogs/{CATALOG_NAME}", token=token)
              if status == 200:
                  # Catalog exists - update it with correct storage config
                  entity_version = resp.get("entityVersion", 1)
                  print(f"  Catalog exists (version {entity_version}), updating storage config...")
                  status, resp = api_request("PUT", f"/api/management/v1/catalogs/{CATALOG_NAME}", {
                      "currentEntityVersion": entity_version,
                      "properties": {
                          "default-base-location": default_base_location
                      },
                      "storageConfigInfo": storage_config
                  }, token)
                  if status in [200, 204]:
                      print(f"  Updated catalog: {CATALOG_NAME}")
                  else:
                      print(f"  Warning: Failed to update catalog storage config: {status} - {resp}")
                      print(f"  Continuing with existing catalog configuration")
              elif status == 404:
                  # Catalog doesn't exist - create it
                  print(f"  Creating new catalog: {CATALOG_NAME}")
                  status, resp = api_request("POST", "/api/management/v1/catalogs", {
                      "catalog": {
                          "name": CATALOG_NAME,
                          "type": "INTERNAL",
                          "properties": {
                              "default-base-location": default_base_location
                          },
                          "storageConfigInfo": storage_config
                      }
                  }, token)
                  if status == 201:
                      print(f"  Created catalog: {CATALOG_NAME}")
                  else:
                      print(f"  Failed to create catalog: {status} - {resp}")
              else:
                  print(f"  Failed to check catalog status: {status} - {resp}")

              # 3. Create layer namespaces with per-layer storage
              print("Creating layer namespaces from declarative config")

              # Extract parent namespaces first (excluding catalog name itself)
              parents = set()
              for layer_name, layer_data in layers.items():
                  namespace = layer_data["namespace"]
                  parts = namespace.split(".")
                  # Skip catalog prefix if present (e.g., "demo_catalog.bronze" -> no parent needed)
                  if len(parts) > 1 and parts[0] != CATALOG_NAME:
                      parents.add(parts[0])

              # Create parent namespaces (if any)
              if parents:
                  for parent in sorted(parents):
                      print(f"Creating parent namespace: {parent}")
                      status, resp = api_request("POST", f"/api/catalog/v1/{CATALOG_NAME}/namespaces", {
                          "namespace": [parent],
                          "properties": {}
                      }, token)
                      if status == 200:
                          print(f"  Created parent namespace: {parent}")
                      elif status == 409:
                          print(f"  Parent namespace already exists: {parent}")
                      else:
                          print(f"  Failed to create parent namespace: {status} - {resp}")

              # Create layer-specific namespaces with per-layer storage
              for layer_name, layer_data in layers.items():
                  namespace = layer_data["namespace"]
                  storage_bucket = layer_data["storage"]["bucket"]
                  storage_endpoint = layer_data["storage"].get("endpoint", STORAGE_ENDPOINT)
                  retention_days = layer_data.get("retention_days")
                  properties = layer_data.get("properties", {})

                  # Strip catalog name from namespace (e.g., "demo_catalog.bronze" -> ["bronze"])
                  # The catalog is already in the URL path: /api/catalog/v1/{CATALOG_NAME}/namespaces
                  ns_parts = namespace.split(".")
                  if ns_parts[0] == CATALOG_NAME:
                      ns_parts = ns_parts[1:]  # Remove catalog prefix

                  print(f"Creating layer namespace: {namespace} (layer={layer_name}, bucket={storage_bucket})")

                  # Create namespace with ONLY location property first (Polaris requirement)
                  # The location property is required and must be set at namespace creation time
                  # IMPORTANT: Polaris expects namespaces as subdirectories, not at bucket root
                  # e.g., s3://iceberg-bronze/bronze/ not s3://iceberg-bronze/
                  create_properties = {
                      "location": f"s3://{storage_bucket}/{layer_name}/"
                  }
                  print(f"  Request payload: namespace={ns_parts}, properties={create_properties}")
                  status, resp = api_request("POST", f"/api/catalog/v1/{CATALOG_NAME}/namespaces", {
                      "namespace": ns_parts,
                      "properties": create_properties
                  }, token)
                  if status == 200:
                      print(f"  Created layer namespace: {namespace}")

                      # Now add custom metadata properties (layer, owner, retention, etc.)
                      metadata_properties = {
                          "layer": layer_name,
                          **properties
                      }
                      if retention_days:
                          metadata_properties["retention_days"] = str(retention_days)

                      if metadata_properties:
                          print(f"  Adding metadata properties: {metadata_properties}")
                          # Build namespace identifier (without catalog prefix for properties API)
                          ns_identifier = ".".join(ns_parts)
                          status, resp = api_request(
                              "POST",
                              f"/api/catalog/v1/{CATALOG_NAME}/namespaces/{ns_identifier}/properties",
                              metadata_properties,
                              token
                          )
                          if status in [200, 204]:
                              print(f"  Updated properties for: {namespace}")
                          else:
                              print(f"  Warning: Failed to add metadata properties: {status} - {resp}")

                  elif status == 409:
                      print(f"  Layer namespace already exists: {namespace}")
                  else:
                      print(f"  Failed to create layer namespace: {status} - {resp}")

              # 4. Create a catalog role with full table privileges
              catalog_role_name = "demo_data_admin"
              print(f"Creating catalog role: {catalog_role_name}")
              status, resp = api_request("POST", f"/api/management/v1/catalogs/{CATALOG_NAME}/catalog-roles", {
                  "catalogRole": {
                      "name": catalog_role_name
                  }
              }, token)
              if status == 201:
                  print(f"  Created catalog role: {catalog_role_name}")
              elif status == 409:
                  print(f"  Catalog role already exists: {catalog_role_name}")
              else:
                  print(f"  Failed to create catalog role: {status} - {resp}")

              # 5. Grant privileges to the catalog role on the catalog
              # These privileges allow table creation and data writes
              privileges = [
                  "CATALOG_MANAGE_CONTENT",  # Create/drop tables and namespaces
                  "TABLE_CREATE",
                  "TABLE_DROP",
                  "TABLE_READ_DATA",
                  "TABLE_WRITE_DATA",
                  "TABLE_LIST",
                  "NAMESPACE_CREATE",
                  "NAMESPACE_DROP",
                  "NAMESPACE_LIST",
                  "VIEW_CREATE",
                  "VIEW_DROP",
                  "VIEW_LIST"
              ]
              for priv in privileges:
                  print(f"  Granting {priv} on catalog to {catalog_role_name}")
                  status, resp = api_request("PUT",
                      f"/api/management/v1/catalogs/{CATALOG_NAME}/catalog-roles/{catalog_role_name}/grants",
                      {
                          "grant": {
                              "type": "catalog",
                              "privilege": priv
                          }
                      }, token)
                  if status in [200, 201]:
                      print(f"    Granted {priv}")
                  elif status == 409:
                      print(f"    Grant already exists: {priv}")
                  else:
                      print(f"    Failed to grant {priv}: {status} - {resp}")

              # 6. Assign the catalog role to the principal role "service_admin"
              # The demo_client principal has service_admin role by default
              principal_role = "service_admin"
              print(f"Assigning catalog role {catalog_role_name} to principal role {principal_role}")
              status, resp = api_request("PUT",
                  f"/api/management/v1/principal-roles/{principal_role}/catalog-roles/{CATALOG_NAME}",
                  {
                      "catalogRole": {
                          "name": catalog_role_name
                      }
                  }, token)
              if status in [200, 201]:
                  print(f"  Assigned {catalog_role_name} to {principal_role}")
              elif status == 409:
                  print(f"  Assignment already exists")
              else:
                  print(f"  Failed to assign catalog role: {status} - {resp}")

              print("Polaris initialization complete!")
              sys.exit(0)
          env:
            - name: POLARIS_URI
              value: "http://{{ .Release.Name }}-polaris:8181"
            - name: CATALOG_NAME
              value: {{ .Values.polarisInit.catalogName | quote }}
            - name: LAYER_CONFIG
              value: {{ .Values.polarisInit.layerConfig | toJson | quote }}
            - name: STORAGE_ENDPOINT
              value: {{ include "floe-infrastructure.storage.endpoint" . | quote }}
            - name: POLARIS_CLIENT_ID
              value: {{ .Values.polarisInit.oauthClientId | default "demo_client" | quote }}
            - name: POLARIS_CLIENT_SECRET
              value: {{ .Values.polarisInit.oauthClientSecret | default "demo_secret" | quote }}
            - name: STORAGE_ROLE_ARN
              value: {{ .Values.polarisInit.storageRoleArn | default "" | quote }}
          resources:
            requests:
              cpu: 50m
              memory: 64Mi
            limits:
              cpu: 200m
              memory: 128Mi
{{- end }}
